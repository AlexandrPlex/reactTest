 ДЖУН:

1) Что такое REST **********************************

"Это архитектурный стиль общения клиента с сервером использующий http запросы(GET, POST, PUT, DELETE)"

2) Как работает this в JS ***********************************

"this указывает на контекст вызова функции, при вызове вне функции указывает на глобальный обьект(window - для браузера)"

3) Как работает наследование на прототипах ***************************

"Ключевая особенность наследования на протатипах заключается в том что при обращении к методуду обькта, если это свойства у  обекта нет его поиск продолжается у обьекта прототипа"

4) Различие значений переменных null, undefined ************************

"
	null и undefined это обьекты,
	null используется для обозначения пустой переменной 
	undefined используется для определения не заданной переменной(
		var a;
		console.log(a) // undefined
	)
"

5) Понятие замыкания **************************

"Замыкания это функция и ее область видимости(Лексическое окружение)
	function count(){
		var a = 0; // Область видемости которая остается доступна функции retFunc даже 			   // после завершения работы функции count
		return function retFunc (){ // функция возврощаемая в результате вызова count
			a += 1;
			return a;
		}
	}
"

6) Различие циклов forEach и map ****************************

"forEach и map это методы для итерации масивов и масивоподобных обьектов получающии в   качестве входных параметров callback функцию котора применяется к каждому элементу массива.
 forEach - применят callback функцию к текущему массиву изменяя его(ничего не возврощает)
 map - формирует новый массив применяет  callback к каждому элементу нового массива и возврощает новый массив.
"

7) Назначение и отличия call, apply, bind **********************************

"Они используются для определения контекста вызова функции, но bind не вызывает функцию а возвращает фукцию с заданным значением this, arg1, arg2 ....
a apply и call сразу вызывают функцию и отлечаются тем что в call передоется неограниченное количество аргументов (this, arg1, arg2 ...), а в apply массив(this, [arg1, arg2 ....]";

8) Всплытие событий *****************************************

"При нажатии в браузере на определенный элемент он вызываетсобытия закрепленные на его родителях и так по цепочке
<body>
	<div>
		<p></p>
	</div>
</body>
При клике на <p> вызываются события на <p> потом на <div> и т.д.
"

9) Как остановить дальнейшее распространение события ***************************************

"Использовать stopPropagation, stopImmediatePropagation, return false"

10) Различие (preventDefault, stopPropagation, stopImmediatePropagation, return false из колбека обработчика) ************

"
	preventDefault - отключет действия браузера по умолчанию
	stopPropagation - останавливает всплытие не блокируя события на текущем элементе(если на данном элементе находится несколько обработчиков они не блокируются)
	stopImmediatePropogation - останавливает всплытия, блокир события на текущем элементе
	return false - отключает действия браузера по умолчанию и останавливает всплытие не блокируя события на текущем элементе
"

11) Разница между == и === *********************************************

"
	== - при сравнении неяно приводит к одному типу(сравнивает без проверки на тип)
	=== - сравнивает с проверкой на тип данных
"

12) "use strict" *********************************

	строгий режим включающий ряд ограничений реализованных в новых спецификациях языка например нелязя неявно создавать пременные в глобольном обьекте

13) let, var, const ************************************

	"
		var - имеет глобальную область видимости, так же поднимается к началу функции(
			console.log(a); // undefined переменная определена но значение не задано
			var a = 5;
			console.log(a); // 5
		)
		let - имеет область видимости ограниченную текущим блоком кода(
			console.log(a); // ошибка т.к. переменной не существует
			let a = 5;
			console.log(a);
		)
		const - имеет область видимости ограниченную текущим блоком кода, а также его нельзя переприсваевать но можно изменить значение используя методы(
			const mass = [1,2,3];
			mass.push(4) // [1,2,3,4]
			mass = [1,2] // ошибка
		)
	"

14) Конструкция для отслеживания (отлова) ошибок в исполняемом коде *******************************

"try...catch(...finaly)
 В try выполняется код в котором ожидается или может возникнуть ошибка, а catch блок в который переходит упровление после её возникновения, а finally выполнится при любом варианте.

"

15) Способы создания объекта (Object.Create, new, {}) **********************************

" 
	{} - создается пустой обьект со ссылкой на прототип object
	new - создается обьект с вызовам конструктора и ссылой на прототип
	Object.Create - устонавнивает прототип обьекта
"

16) Основные нововведения ES6 по сравнению с ES5 ********************************

"
	классы, стрелочные функции, деструктуризация, Шаблонные строки(`${}`), let
"

17) Отличия ES6 классов и ES5 функций-конструкторов ************************************

"
Проявился новый синтаксис:
constructor - конструктор класса
super - обращение к конструктору родительского класса или методам родительского класса
class - обьявление класса
extends - указание класса от которого унаследован текущий
ES5
	var function constructor (name){
		this.name = name;
	}
	constructor.prototype.metod = function sayName (){
		console.log(`I am ${this.name}`);
	}
	var humen = new constructor('Вася');
	humen.metod();
ES6
	class Humen{
		constructor(name){
			this.name = name;
		}
		sayName (){
			console.log(`I am ${this.name}`);
		}
	}
	var humen = Humen('Jon');
	humen.sayName();
"

18) Стрелочные функции ****************************************

"
	Стрелочные функции отличаются отсутствием своего this, они сохраняют this лексического окружения в котором были обьявлены.
"

19) Деструктуризация ***************************************

"
	деструктурируемое присваевание испольуется для передачи состоляющих обьекта пр присваивании или передачи аргументов.
	mass = [1,2];
	var [a,b] = mass;
"

20) Оператор спред (...) *************************************

"
	ператор spread истользуется для расширения переменных например 
	mass = [1,4,3];
	mass2 = [...mass]; // ...mass = 1 4 3 

	function a(...res){
		console.log(res);
	}
	a(1,2,3,4) // [1,2,3,4]
"

21) Promises and/or their polyfills *********************************

"
	promises это обьект содержащий свое состояние. В качестве параметров он получает две функции reject, resolve которые выполняются в случаях если выполнени завершилось успешно или с ошибкой(по результату они возвращают свое состояние).Они преднозначены для асинхронного выполнения кода.
	promise().then(() => {} // callback функция
	).catch(); // при этом then ожет быть сколько угодно
"

22) AMD vs CommonJS *****************************************

"
	Это способы подключения внешних модулей

	AMD

	define(['dep1', 'dep2'], function (dep1, dep2) {

    //Определение модуля с помощью возвращаемого значения
    return function () {};

    CommonJS

    var dep1 = require('./dep1');  
    var dep2 = require('./dep2');
});
"
